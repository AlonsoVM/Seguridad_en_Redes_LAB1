Para analizar e intentar descubrir que es lo que hacen estos dos binarios vamos a seguir los mismos pasos para ambos, primero realizaremos un analisis de los binarios por separados, primero bob y luego Alice y observar asi su comportamiento, posteriormente intentaremos hacer un seguimiento de las llamadas al sistema que realizan ambos programas por separado, y en caso de que fuese necesario realizaremos una analisis de la red en el caso de que generen trafico o se comuniquen entre ellos
# Analisis individual de bob
Lo primero que hemos realizado, aunque se obvio, es ejecuar el binario bob, no obstante no hemos obtenido ningún tipo de salida, además el programa parece no terminar por lo que puede ser que este programa este esperando a recibir alguna información desde otro sitio.
## Analisis del binario bob.
Para realizar el analisis de este análisis, lo primero que hemos hecho ha sido buscar alguna herramienta para poder observar las cadenas que existan dentro del binario, ya que este puede tener información insertada dentro del propio binário o también  averiguar alguna dirección de internet como una URL o algún nombre. Para ello primero hemos utilizado la herramienta **objdump**, **hexdump**, **ldd** y **strings** la cual nos permite pasar el binario a un formato hexadecimal y obtener alguna información sobre las cadenas de este bianrio.
Para ello ejecutaremos los siguientes comandos:
   * **objdump -p bob > bob_private-heders.hex**:
    Con la opción -p indicamos que queremos obtener los headers privados del archivo, y obtenemos información interesante y es que nos encontramos que este programa necesita de las librerías **libpthread.so.0** y **libc.so.6** (poner imagen bob_privateHeaders.txt), por lo tanto es bastante posible que este programa cree varios hilos de ejecución.

   * Como hemos mencionado anteriormente es muy probable que bob este creando varios hilos de ejecución, asique para ello vamos a probar a ejecutar el programa desde la terminal en segundo plano y comprobar el numero de hilos que este tiene. Como sospechabamos bob crea un total de 7 hilos de ejecución dicha información se encuentra en N-hilos_bob.png

   * **hexdump -C bob > bob.hex**: Con esta herramienta lo que conseguimos es pasar la representación del codigo binario a hexadecimal y además nos permite ver algunas cadenas internas del programa. No obstante el programa parece estar cifrado de alguna manera pues la mayoría de las cadenas son ilegibles, aun así podemos obtener alguna información extra, como que el lenguaje que se a utilizado para construir el binario es **go** ya que encontramos algunas rutas en la maquina en la que se compilo dicho archivo, además también parece que el programa en algún momento intentará conectarse a la red, pues podemos encontrar alguna cadena dentro del binario que hace referencia a sockets. Indagando más podemos afirmar que en algún momento se conectará por red ya que podemos encontrar la llamada al sistema **syscall.sendto** y no solo esto si no que también escuchara información procedente de otro proceso o sitio web ya que tambien nos podemos encontrar la llamda al sistema **syscall.recvfrom**. Cabe destacar que para filtrar la informacion del archivo nos hemos apoyado de cat y grep de la siguiente manera: **cat bob | grep <keyword>** cabe destacar que **keyword** lo hemos ido cambiando en función de lo que deseasemos buscar.

   * Siguiendo con lo anterior y sabiendo que dicho programa es muy probable que este utilizando sockets, he probado a filtrar la salida por tcp para ver si dicho programa utiliza tcp o udp, en principio utiliza tcp, esto lo contrastaremos más adelante cuando utilicemos alguna herramienta para analizar el trafico de red.

   * A continuación, hemos procedido a realizar un seguimiento mas profundo de las dependencias del programa, para ello nos vamos a apoyar en el herramienta **ldd**, para ello ejecuatamos el comando **ldd bob**, el cual no nos muestra gran cantidad de información, lo único es que encontramos la librería libpthread.so.0 cosa que ya habiamos demostrado anteriormente.

   * Por ultimo vamos a realizar un analisis completo de las cadenas mediante la herramienta strings, para ello ejecutamos el siguiente comando **strings bob > Strings_bob.txt**, gracias a este comando obtenemos información sobre las diferentes librerías de go que se han necesitado para crear el binario, además tambien hemos obtenido rutas del ordenador sobre el que se compilo el programa como: **/home/cleto/bin/go/src/internal/cpu/cpu.go**, además también hemos encontrado cierta informacion sobre las estructuras que utiliza bob, para ello hemos flitrado la informacion del archivo Strings_bob.txt por la palabra **struct** no obstante la información no parece ser muy relevante. Tambien hemos econtrado información como que utiliza la librería **mutex** para sincronizar los hilos.

## Analisis del binario bob en ejecución:
Para este analisis utilizaremos las herramientas strace, la cual nos permite realizar un seguimiento de las llamdas al sistema que realiza un programa en ejecuión, y tambien lsof para ver los archivos abiertos que maneja bob.

* Primero vamos a ejecuar el programa con strace, para ello usaremos el siguiente comando **strace -o llamadas_solo_bob.txt ./bob**, como era de esperar el programa parece no terminar, no obstante, obtenemos información que nos sirve para reafirmar que bob utiliza socket TCP como se muestra en la siguiente imagen (imagen socket_TCP_bob.png)

* Además hemos encontrado que bob intenta conectar al puerto 12345, como se muestra en la siguiente imagen (socket_connect_bob.png) como se puede observar en la imagen la operación se repite varias veces y se mantiene en curso, lo que puede llegar a indicar que no existe un proceso adecuado encuchando en el puerto 12345, para comprobar esto hemos utilizado el siguiente comando **netstat -an | grep 12345** y no hemos obtenido ninguna salida, lo que nos indica que efectivamente no existe ningun proceso escuchando en ese puerto, además en la imagen tambien podemos observar que la direccion IP es la 127.0.0.1 es decir nuestra propia máquina, por lo que es muy probable que bob en cierta manera intente conectarse con un proceso local mediante la  dirección **127.0.0.1:12345** dicho proceso, puede ser alice, o algun otro proceso que el propio alice carge en memoria.

* Adicionalmente, tambien se ha encontrado, que bob intenta realizar una operación de lectura de la dirección **127.0.0.1** por lo que parece a la espera de recivir datos.

* Respecto al numero de hilos, podemos observar mediante la herramienta lsof, usando el siguiente comando **lsof | grep bob** como tiene una serie de archivos abiertos el proceso y además como tiene una seria de archivos por cada hilo, cabe destacar que estos archivos se repiten por hilo como muestra la siguiente imagen (adjuntar imagen lsof_bob_solo). Cabe destacar que esta estructura se repite hasta la Id del hilo 307948, no obstante, estas ids entre ejecución y ejecución pueden variar.

* Por ultimo, se ha observado que el programa cuando se ejecuta intenta obtener información de la ruta absoluta en la que se esta ejecutando, ya que dentro de las llamadas al sistema hemos encontrado lo siguiente (insertar imagen readlinkat_bob.png), cabe destacar que esta información va a variar dependiendo del directorio donde se encuentre bob, por ejemplo esta imagen muestra el mismo resultado cuando bob se ejeucta en el direcotrio home (adjuntar imagen readlinkat_homo_bob.png)

## Conclusiones analisis individual de Bob:
Una vez realizado el analisi 
* Bob crea varios hilos probablemente con el objetivo de que alguno de ellos se encargue de manejar la información que se le pase por red y el reste pueden realizar taréas como encriptar mensajes o procesar los mensajes para realizar alguna acción en el ordeandor del usuario.

* Tras ejecutar bob, hemos comprobado que el propietario de los diferentes procesos es el mismo que con el que se lanza, por lo que bob no parece intentar escalar de alguna manera en privilegios dentro del sistema.

* A nivel interno no parece realizar nada pero intenta conectar a la dirección **127.0.0.1:12345** por lo que es muy probable que al analizarlo junto a alice obtengamos otros resultados

Con esta información, vamos probar a poner un proceso de netcat a la escucha en el puerto 12345 y ejeucutar bob a ver que sucede, para ello ejecutamos el siguiente comando: **nc -l -p 12345**, con esto conseguimos que bob hable con nuestro servidor, el problema que ocurre es que al intentar realizar el **handshake** entre las dos partes, obtenemos fallos, probablemente por que bob este demando algún tipo de clave para cifrar la conexión. Esto se muestra en la siguiente imagen (adjuntar imagen handshake_bob.png).

Por lo tanto, es probable que para averiguar más funcionalidades sobre el programa bob sea necesario obtener más información sobre alice, o ejecutarlos conjuntamente.

# Analisis Individual de alice
Para analizar la funcionalidad de alice, vamos a utilizar las mismas herramientas que hemos usado con bob.
## Analisis estático de alice:
* **objdump -p alice > alice_private_heders.txt**:
   En este caso la información que obtenemos es muy parecida a la que hemos obtenido con bob, ya que encontramos que necesita las librerías **libpthread.so.0** y **libc.so.6** de tal modo que al igual que bob es muy probable que alice cree varios hilos de ejecución. Para comprobar si alice ejecuta más de un hilo, vamos a lanzarlo en segundo plano en una terminal, y posteriormente obtendremos el número de hilos. (Adjuntar imagen N_hilos_alice.png) En este caso, podemos observar que alice crea un total de 8 hilos.

* **hexdump -C alice > alice.hex**:
   A continuacion hemos probado a pasar el binario alice a hexadecimal con el objetivo de buscar alguna cadena de texto que nos pueda proporcionar información.
   Una vez realizado esto hemos encontrado algunas llamdas como **syscall.socket** por lo que al igual que en el caso de bob alice, muy posiblemente esta utilizando socket para acceder a la red o comunicarse con otros procesos. También y suponiendo que alice puede hacer de cliente hemos filtrado por la palabra **client** y hemos encontrado bastante información, como se muestra en la imagen, (adjuntar imagen client_alicehex.png) parace que existe un **helloMsg** que alice enviará a algún sitio, tambien podemos observar como aparece **http2client** por lo que puede ser que alice realice algún tipo de petición http. También se puede observar que aparece varias veces repetida la palabra **tls**, por lo que es muy posible que alice utilice este protocolo para comunicarse y cifrar los mensajes, además se observa la palabra **dns** por lo que puede ser que alice intente conectarse a un servidor externo. Por ultimo, tambien hemos probado a buscar palabras clave como url, send, sendto, tls, key, y lo que hemos obtenido es que, al igual que bob el programa esta hecho con go, utiliza tls y también junto a tls aparecía la palabra key, por lo que es muy probable que necesitemos alguna clave para descifrar los mensajes, además alice tambien realiza la llamada **syscall.recvfrom** por lo que a parte de enviar información también recibe.

* **ldd alice**: A continuación se han examido las dependencias del binario por si existiese alguna diferente a las que tiene bob, aunque las librerias que hemos obtenido en este caso son las mismas que las de bob.

* **strings alice**:Por ultimo vamos a probar a buscar strings más profundamente en el binario, los resultados se han guardado en el archivo **strings_alice.txt**, apoyandonos en la información anterior, hemos probado a filtrar por la palabra **message**, y se encuentra casi siempre acompañada por la palabra dns, por lo que estamos practicamente seguros de que alice realizará alguna petición dns. Al filtar por la palabra **tls** obtenemos bastante información,  ya que parece que se realizan operaciones de **handshake** y **intercambia algun tipo de certificado** como se puede ver en la imagen. (tls handshake alice, tls alice 2)
En la segunda imagen, también podemos observar como se siguen una serie de pasos con el modulo de tls, además supongo que las repetidas operasion de marshal y unmarshal se deben a que estos mensajes se estan utilizando para una comunicación a traves de red o a traves de la maquina local, tambien podemos observar algunas cadenas como: **clientHelloMsg**, **serverHelloMsg**, **helloRequestMsg** por lo que estos mensajes se pueden estar utilizando en la comuniación, además podemos ver que a estos punteros, posteriormente se les aplica unas funciones de marshaling como las siguientes. (Imagen marshal-alice.png)
También hemos filtrado por **http** **https** **connect**, no obstante no se ha encontrado mucha información, lo unico es que aparece gran cantidad de veces la palabra http en comparación con bob por lo que probablemente alice haga un uso mucho mas exahustivo de la red.

## Analisis del binario alice en ejecución:

* Primero vamos a comprobar las llamadas al sistema que realiza el programa, para ello usamos la herramienta strace, los resultado se guardan en el archivo **llamadas_solo_alice.txt**, al igual que en el caso de bob el programa parece no terminar, esto puede ser debido a que se necesiten ejecutar los dos a la vez para que ambos terminen. Al filtrar por **socket**, nos encontramos que a diferencia de bob, alice, crea tanto un socket TCP como un socket UDP (**SOCK_STREAM** y **SOCK_DGRAM**), esto tiene mucho sentido teniendo en cuenta que en el analisis estático del programa nos hemos encontrado que este realiza una petición DNS, ya que estas peticiones se realizan mediante UDP, es decir mediante un **SOCK_DGRAM**. Al filtar por **recv** nos encontramos que alice realiza un recv y encontramos la cadena gitlab.com por lo que podemos pensar que la petición DNS se realiza para resolver el nombre gitlab.com.
Al filtrar por la palabra read, nos encontamos información interesante, pues parece que alice lee de alguna parte información de un certificado, probablemente un certificado ssl.

* Tenindo en cuenta la información obtenida de bob, vamos a usar **lsof -i** para comprobar si alice utiliza el puerto 12345, que es con el que bob intentava conectar, como se puede observar en la imagen, (adjuntar imagen lsof alcie.png) alice se encuentra escuchando en el puerto 12345 que es el puerto al que bob intentaba conectarse, per además, tambien podemos ver como alice tiene una conexion establecida con la ip **172.65.251.78** a través del puerto **50606** no obstante se ha comprobado que este puerto varía de ejecucion en ejecución. En principio la ip **172.65.251.78** se debería corresponder con **gitlab** ya que era sobre este nombre sobre el que alice realizaba una petición DNS, para comprobarlo se ha utilizado el comando nslookup, y como era de esperar la ip anteriormente mencionada coincide con el nombre gitlab.

* Por ultimo vamos, vamos a utilizar wireshark para analizar la comunicación que alice tiene con el exterior, como se puede apreciar en la imagen, (adjuntar imagen wireshark_solo_alice.png), como hemos mencionado anteriormente, alice realiza una petición DNS, una vez resuelta, se conecta mediante tcp a gitlab.com y hacen el **handshake** una vez realizado esto, alice envia por TLS el mensaje que dice **Client Hello**, mensaje que ya nos habiamos encontrado dentro de alice cuando hemos analizado los strings que contenia su codigo, además el servidor le responde **Server Hello, Change Cipher Spec** que puede ser que tenga algo que ver con el **serverHelloMsg** encontrado durante el analisis de los strings de alice, por ultimo alice responde con un mensaje así **Change Cipher Spec, Application Data**, por lo que esto podría ser una manera de ponerse de acuerdo en como encriptar las comunicaciones. Importante resaltar que alice establece la comunicación siempre con el puerto 443.

## Conclusiones analisis individual de Bob:

* Alice realiza una petición DNS a gitlab.com con ip 172.65.251.78, además alice accede mediante http a un recurso de gitlab.com.
* Alice utiliza la red de manera activa a diferencia de bob.
* Alice utiliza tls para encryptar los mensajes.
* Alice se pone a la escucha en el puerto 12345 mediante tcp, y se comunica mediante el loopback con bob.

# Análisis de la ejecución conjunta de ambos procesos.
En esta sección vamos a analizar el comportamiento que tienen alice y bob cuando se ejecutan conjuntamente, no obstante, el analisis estático del codigo no le vamos a repetir ya que obtendremos los mismos resultados.

## Analisis de las llamadas al sistema.
Para ello vamos a utilizar **strace** y vamos a esperar a ver si la ejecución de ambos programas termina, los resultados de las llamas al sistema se han gurdado en los archivos llamadas_bob_conjuntas.txt y llamadas_alice_conjuntas.txt. La primera diferencia que observamos es que ahora si ambos programas terminan su ejecución. Una vez obtenidos los archivos vamos a probar a filtrar por las mismas palabras que cuando los analizamos individualmente para ver si algo a variado.

   * **llamadas_bob_conjuntas**: Al filtrar por connect, a diferencia de cuando de ejecutaba solo, ahora bob solo realiza una sola vez la operación connect sobre la dirección 127.0.0.1:12345, ya que esta vez alice se encontraba en ejecución y se pone a la escucha en esa dirección. Tambien podemos observar que bob al realizar la operación read sobre esta dirección 127.0.0.1:12345 obtiene información a diferencia de cuando se ejecutaba solo, cosa que era de esperar.

   * **llamadas_alice_conjuntas**: La primera diferencia, la encontramos al filtrar por la palabra **write**, pues parece ser que alice escribe sobre el descriptro de archivo 8 una seria de caracteres ilegibles, probablemente encriptados, y sobre el descriptor de archivo 5 siempre escribe un 0. Al filtrar por pipe, encontramos que crea una tubería con los descriptores de archivos 4 y 5, por lo tanto hemos decidido filtrar por **close** para ver si podemos encontrar información relativa a como el programa maneja las tuberías y descriptores de archivos, al filtrar obtenemos que realiza varias veces esta operación sobre los descriptores de archivos 3, 6 y 7. Al filtrar por **read** nos hemos encontrado que alice lee a traves del descriptor de archivo 7 un certificado, ya que encontramos lo siguiente **read(7, "-----BEGIN CERTIFICATE-----\nMIIF"..., 2022) = 2021**, además tambien lee del descriptor 4 un 0 siempre, cosa que tiene sentido por que hemos visto antes que alice siempre escribia 0 sobre el descriptor 5 y los descriptores de archivo 4 y 5 se habían utilizado para crear una tubería, y por ultimo el descriptor 8 del que siempre se lee la palabra **OK** por lo que es posible que de aquí se este obteniendo información, además algunas veces aparece esto: **read(8, 0xc0000c2778, 2)= -1 EAGAIN (Recurso no disponible temporalmente)** lo que parece ser una operación de lectura que falla sobre una dirección de memoria y posteriormente se retpite.

## Analisis de la red:
A continuación vamos a utilizar wireshark para observar la comunicación que mantiene alice con el exterior y entre alice y bob, para ello primero vamos a analizar el trafico de mi tarjeta de red **wlo1** en wireshark para ver la comunicación con gitlab.com, posteriormente y sabiendo que alice y bob se comunican por el loopback analizaremos el trafico de esa interfaz.

### Analisis wlo1:
La comunicación que mantiene alice, parece ser la misma que en el caso en el que la ejecutamos de manera aislada, no obstante, tras finalizar la comunicación con gitlab.com, parece que alice y bob permanecen en ejecución bastante más teimpo, por lo que puede ser que alice primero descargue unos datos de gitlab.com y posteriormente, realicen alguna operación entre ambos binarios, por lo que más adelante analizaremos los dos traficos en conjunto. (Captura wireshark en captura_alice_conjunta_wlo1), en total alice obtiene de gitlab.com 1188188 bytes, pero por alguna extraña razon tras repetir la ejecución variás veces, por alguna razón al final de la transmisión siempre se produce un error en la conexión que hace que se prolonge hasta 90 segundos más.

### Analisis loopback
Al ejecutarlo, observamos que bob se conecta con la dirección **127.0.0.1:12345**, una vez conectado, y hecho el handshake, se intercambian información que esta totalmente encriptada por algun protocolo, además hemos observado que en esta ejecución han intercambiado un total de 2151301 bytes no obstante, han tardado un total de 223 segundos, lo que resulta bastante tiempo para una transferencia de apenas uno MB. (Captura wireshark en loopback) Por lo que podria ser que ambos programas forzasen esta situación.